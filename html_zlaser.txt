
The z_laser_projector ROS package is a device wrapper to operate the [[https://z-laser.com/en/product/laser-projector/zlp1/|ZLP1 Z-LASER]] projector. This package provides a collection of services in order to handle the device and simplify the task of develop further advanced features.
                                  to ease the device handling and simplify the task of develop further advanced features.

Maintainer status: maintained
Maintainer: Rafael Luque Berraquero <rluque AT catec DOT aero>
Author: Ines Lara Sicilia <imlara AT catec DOT aero>
License: Apache 2.0
Source: git https://github.com/fada-catec/--------.git (branch: master)


## AUTOGENERATED DON'T DELETE
## CategoryPackage
<<PackageHeader(z_laser_projector)>> <<TOC(4)>>

== Overview ==

ZLP1 is a eye-safe laser projector (laser class 2M) used to project desired objects and figures as an optical guidance system in industrial applications like pick-and-place, logistics, and workstations, endeavouring to enlarge and optimize the production and workflow. 

. {{attachment:zlaser_applic.png||height="250px",width="600px"}}

<<Youtube(uZy0WAPN304)>>


This device is the smallest laser projector in the [[https://z-laser.com/en/product-area-laser-projectors/|Z-LASER ZLP]] family. 


https://www.youtube.com/watch?v=uZy0WAPN304
https://www.youtube.com/watch?v=CvjINQtj5ZU


=== Software architecture ===

The ZLP software has a modular architecture. The different components communicate via TCP/IP and may be located on different system in the same network.

. {{attachment:architecture.png||height="250px",width="600px"}}


''__ROS-Node__'': This is the user application to configure and control the ZLP system.

''__ZLP-Service__'': The ZLP Service (zService) is the core component of the laser projection system. It processes all commands and does all calculations. It communicates with one or multiple laser projectors over the network. The ZLP Service recieves commands from client applications as the ROS Node. The communication between clients and ZLP Service is based on the Thrift network protocol.

''__Thrift-Interface__'': Thrift is a framework of the Apache coorporation which consist of a software library, a network protocol and a compiler. It offers a plattform independent and programming language independent way of communicating between distributed applications. The interface is described in an interface definition file. A compiler can use this file to generate code for the interface in many different programming languages. The Thrift interface of the ZLP Service is the main interface for all applications, which want to use the ZLP system. It can be used to send commands, transfer projection data or request status information.


=== Reference systems ===

Specifications
covers working fields from 1.0m x 1.0m up to 3.5m x 3.5m. Possible working distances range from 1.0m to 3.0m.

The laser projector ZLP1 is used for projection of any polygons on any scale, which result from files of the construction and manufacturing. 
The projector is capable of projecting the display object at correct position and location at various workpiece heights. 
Similarly, a displayed object can be moved and rotated.



== Package files ==

The package is structured as follows:

{{attachment:zlaser_tree.png||height="514px",width="700px"}}

=== Source file ===
 * [z_laser_projector/src]
  * '''interface.thrift''': 
  * '''zlp.py''': 
  * '''utils.py''': 
  * '''projector_manager.py''': 
  * '''projection_node.py''': 



  * '''zlp.py''': defines the class "Grid3d". It works with the grid from the map.bt, opening it, building the grid message and pointcloud map and calculating compute the weights.
  * '''Grid.cpp''': implements the functions of the class "!Grid3d". 
  * '''!PointCloudTools.h''': defines the class "!Grid3dCell", "!Grid3dInfo" and "!PointCloudInfo". It creates the grid from the map.bt, computing the weights of the grid.
  * '''!PointCloudTools.cpp''': implements the functions mentionated in "!PointCloudTools.h". It is relationated with the information of the grid.
  * '''main.cpp''': inits the function "spin" of the class "Node".
  * '''Node.cpp''': implements the functions of the class "Node". It contains all the subscribers and publishers of the package, so it has the responsibility to start the map grid and follow the steps of the particle filter.
  * '''Node.h''': defines the class "Node". It runs the grid and the particle filter with the parameters that were introduced into the roslaunch file.
  * '''Parameters.cpp''': implements the parameter readings, and shows errors if the parameters have not been initialized, in addition to displaying the value of all of them on the screen. For more information, see section '''__3.1.3. Parameters__'''.
  * '''Parameters.h''': defines the class "Parameters". It declares all the generic parameters of the node. 
  * '''!ParticleFilter.cpp''': implements the functions of the class "!ParticleFilter". It has the steps mentioned before: functions of prediction, update, and resampling. Furthermore, it has other functions such as one that allows calculating the weight of the particle taking into account the error in the range sensors.
  * '''!ParticleFilter.h''': defines the class "!ParticleFilter". It runs the steps of the Monte-Carlo method.

=== Launch ===
 * [z_laser_projector/launch]
  * '''projector_zlp1.launch''': starts amcl3d node with a selected configuration of parameters.
  {{{
  roslaunch z_laser_projector projector_zlp1.launch
}}}

=== Tests ===
 * [z_laser_projector/test]
  * '''test_libraries.py''': it contains a configuration of RViz that allows displaying the topics of interest: the different point-clouds used in the algorithm, the particles, the transformations, and the localization of range-sensor.


== Node ==
{{{
#!clearsilver CS/NodeAPI
node.0 {
  name= projection_node
  desc= 
  
  The first thing the algorithm does is wait for odometry messages. If it receives them, then it waits for the robot take-off marked on the takeOffHeight_ parameter. Then, the filter begins to perform the prediction/update/resampling steps according to the point-clouds of the laser sensor and the radio-range sensor measurements, calculating particle weights. It also updates a TF for the robot.
srv{
  0.name= ~connect
  0.type= projector_srv/connect
  0.desc= Connect to service and activate projector.
  1.name= ~disconnect 
  1.type= projector_srv/disconnect
  1.desc= Disconnect from service and deactivate projector.
  2.name= ~load_license 
  2.type= projector_srv/load_license
  2.desc= Send license to service.
  3.name= ~setup
  3.type= projector_srv/setup
  3.desc= Connect to service, activate projector and send license.
  4.name= ~projection_start
  4.type= projector_srv/projection_start
  4.desc= Start projection of elements from the __current__ coordinate system (see set_cs service).
  5.name= ~projection_stop
  5.type= projector_srv/projection_stop
  5.desc= Stop projection.
  6.name= ~man_def_cs
  6.type= projector_srv/man_def_cs
  6.desc= Define a new coordinate system manually, stating points coordinates by the user.
  7.name= ~cs_list
  7.type= projector_srv/cs_list
  7.desc= Get list of defined coordinate systems.
  8.name= ~set_cs
  8.type= projector_srv/set_cs
  8.desc= Set the current coordinate system, because some services as 'add_shape' apply automatically to the current coordinate system. It means that the set coordinate system become in the coordinate system to operate with and the rest stay on background until any is set again.
  9.name= ~show_current_cs
  9.type= projector_srv/show_current_cs
  9.desc= Project current coordinate system.
  10.name= ~remove_coord_sys
  10.type= projector_srv/remove_coord_sys
  10.desc= Remove current coordinate system.
  11.name= ~add_shape
  11.type= projector_srv/add_shape
  11.desc= define properties of a new shape (line, circle, ...) and add it to the current coordinate system.
  12.name= ~hide_shape
  12.type= projector_srv/hide_shape
  12.desc= Hide specific shape from current coordinate system.
  13.name= ~unhide_shape
  13.type= projector_srv/unhide_shape
  13.desc= Unhide specific shape from current coordinate system.
  14.name= ~remove_shape
  14.type= projector_srv/remove_shape
  14.desc= Remove specific shape from current coordinate system.
  }
}}}




 == Licensing ==

 A license is always required to use the ZLP software, whether the system is controlled through the ZLP-Suite or the Thrift interface. The license defines for how long the software can be used and which features are available.
 
 There are two kinds of license: a system-based license and a projector-based license. A system-based license is better suited for development purposes. It is also mandatory in all cases when only the projector simulator is used for development.

== Demostration Video ==

<<Youtube(zznQPPagasI&)>>

== Acknowledgement ==

{{attachment:rosin.png||height="200px",width="575px"}}

Supported by ROSIN - ROS-Industrial Focused Technical Projects (FTP).  

More information: [[http://rosin-project.eu/|rosin-project.eu]]

